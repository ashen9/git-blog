# Event Loop
虽说目前chrome已经支持worker，js可以多线程运行了，但webworker仅仅能进行计算任务，不能操作DOM，所以本质上还是单线程。

## 线程  
  1. js运作在浏览器中,是单线程的，即js代码始终在一个线程上执行，这个线程称为js引擎线程。  
  2. 浏览器是多线程的，除了js引擎线程，它还有： UI渲染线程、浏览器事件触发线程、http请求线程、EventLoop轮询的处理线程...
  3. 多线程之间会共享运行资源，浏览器端的js会操作dom，多个线程必然会带来同步的问题，所有js核心选择了单线程来避免处理这个麻烦。js可以操作dom，影响渲染，所以js引擎线程和UI线程是互斥的。这也就解释了js执行时会阻塞页面的渲染。
## 同步任务
  在主线程排队支持的任务，前一个任务执行完毕后，执行后一个任务,形成一个执行栈，线程执行时在内存形成的空间为栈，进程形成堆结构，这是内存的结构。
## 异步任务  
  异步任务会被主线程挂起，不会进入主线程，而是进入消息队列，而且必须指定回调函数，只有消息队列通知主线程，并且执行栈为空时，该消息对应的任务才会进入执行栈获得执行的机会。
## js运行机制
  1. 所有同步任务都在主线程上执行，形成一个执行栈。 
  2. 主线程之外，还存在一个”任务队列”。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 
  3. 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
  4. 主线程不断重复上面的第三步。
## Event Loop
  主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

  简单说，浏览器的两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。
## Task和Microtask
* Task：是严格按照时间顺序压栈和执行的，所以浏览器能够使得 JavaScript 内部任务与 DOM 任务能够有序的执行。
* Microtask 通常来说就是需要在当前 task 执行结束后立即执行的任务

